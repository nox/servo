/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

//! The `SourceBuffer` DOM implementation.

use dom::bindings::cell::DomRefCell;
use dom::bindings::codegen::Bindings::MediaSourceBinding::MediaSourceMethods;
use dom::bindings::codegen::Bindings::MediaSourceBinding::ReadyState;
use dom::bindings::codegen::Bindings::SourceBufferBinding;
use dom::bindings::codegen::Bindings::SourceBufferBinding::AppendMode;
use dom::bindings::codegen::Bindings::SourceBufferBinding::SourceBufferMethods;
use dom::bindings::error::{Error, ErrorResult, Fallible};
use dom::bindings::inheritance::Castable;
use dom::bindings::num::Finite;
use dom::bindings::reflector::{DomObject, reflect_dom_object};
use dom::bindings::refcounted::Trusted;
use dom::bindings::root::{DomRoot, MutNullableDom};
use dom::eventtarget::EventTarget;
use dom::mediasource::MediaSource;
use dom::window::Window;
use dom_struct::dom_struct;
use js::jsapi::{JSContext, JSObject, Rooted};
use js::typedarray::{ArrayBuffer, ArrayBufferView};
use mime::{Mime, SubLevel, TopLevel};
use std::ascii::AsciiExt;
use std::cell::Cell;
use std::collections::VecDeque;
use std::f64;
use task_source::TaskSource;

/// A `SourceBuffer` DOM instance.
///
/// https://w3c.github.io/media-source/#idl-def-sourcebuffer
#[dom_struct]
pub struct SourceBuffer {
    eventtarget: EventTarget,
    /// https://w3c.github.io/media-source/#parent-media-source
    parent_media_source: MutNullableDom<MediaSource>,
    /// https://w3c.github.io/media-source/#sourcebuffer-generate-timestamps-flag
    timestamp_mode: TimestampMode,
    /// https://w3c.github.io/media-source/#dom-sourcebuffer-mode
    append_mode: Cell<AppendMode>,
    /// https://w3c.github.io/media-source/#sourcebuffer-append-state
    append_state: Cell<AppendState>,
    /// https://w3c.github.io/media-source/#sourcebuffer-group-start-timestamp
    group_start_timestamp: Cell<Option<Finite<f64>>>,
    /// https://w3c.github.io/media-source/#sourcebuffer-group-end-timestamp
    group_end_timestamp: Cell<Finite<f64>>,
    /// https://w3c.github.io/media-source/#sourcebuffer-input-buffer
    input_buffer: DomRefCell<VecDeque<u8>>,
    /// https://w3c.github.io/media-source/#sourcebuffer-buffer-full-flag
    buffer_full: Cell<bool>,
    /// The MIME type provided when that `SourceBuffer` was created.
    #[ignore_heap_size_of = "defined in mime"]
    mime: Mime,
    /// Whether we are currently running the range removal algorithm.
    in_range_removal: Cell<bool>,
    /// https://w3c.github.io/media-source/#dom-sourcebuffer-updating
    updating: Cell<bool>,
    /// https://w3c.github.io/media-source/#dom-sourcebuffer-timestampoffset
    timestamp_offset: Cell<Finite<f64>>,
    /// https://w3c.github.io/media-source/#dom-sourcebuffer-appendwindowstart
    append_window_start: Cell<Finite<f64>>,
    /// https://w3c.github.io/media-source/#dom-sourcebuffer-appendwindowend
    append_window_end: Cell<f64>,
}

/// https://w3c.github.io/media-source/#sourcebuffer-append-state
#[derive(Clone, Copy, JSTraceable, HeapSizeOf, PartialEq)]
enum AppendState {
    WaitingForSegment,
    ParsingInitSegment,
    ParsingMediaSegment,
}

/// https://w3c.github.io/media-source/#sourcebuffer-generate-timestamps-flag
#[derive(Clone, Copy, JSTraceable, HeapSizeOf, PartialEq)]
enum TimestampMode {
    /// Timestamps are extracted from source.
    FromSource,
    /// Timestamps are generated by the source buffer itself.
    Generated,
}

impl SourceBuffer {
    pub fn new(
        parent_media_source: &MediaSource,
        mime: Mime,
    ) -> DomRoot<Self> {

        reflect_dom_object(
            box Self::new_inherited(parent_media_source, mime),
            &*parent_media_source.global(),
            SourceBufferBinding::Wrap,
        )
    }

    pub fn is_active(&self) -> bool {
        // FIXME(nox): Actually implement this correctly.
        false
    }

    pub fn clear_parent_media_source(&self) {
        debug_assert!(self.parent_media_source.get().is_some());
        self.parent_media_source.set(None);
    }
}

impl SourceBufferMethods for SourceBuffer {
    /// https://w3c.github.io/media-source/#dom-sourcebuffer-mode
    fn Mode(&self) -> AppendMode {
        self.append_mode.get()
    }

    /// https://w3c.github.io/media-source/#dom-sourcebuffer-mode
    fn SetMode(&self, new_mode: AppendMode) -> ErrorResult {
        // Step 1.
        let parent_media_source = match self.parent_media_source.get() {
            Some(source) => source,
            None => return Err(Error::InvalidState),
        };

        // Step 2.
        if self.updating.get() {
            return Err(Error::InvalidState);
        }

        // Step 3.
        // The argument is already named new_mode.

        // Step 4.
        if self.timestamp_mode == TimestampMode::Generated && new_mode == AppendMode::Segments {
            return Err(Error::Type("New mode cannot be \"segments\".".to_owned()));
        }

        // Step 5.
        if parent_media_source.ReadyState() == ReadyState::Ended {
            // Step 5.1.
            parent_media_source.set_ready_state(ReadyState::Open);

            // Step 5.2.
            let window = DomRoot::downcast::<Window>(parent_media_source.global()).unwrap();
            window.dom_manipulation_task_source().queue_simple_event(
                parent_media_source.upcast(),
                atom!("sourceopen"),
                &window,
            );
        }

        // Step 6.
        if self.append_state.get() == AppendState::ParsingMediaSegment {
            return Err(Error::InvalidState);
        }

        // Step 7.
        if new_mode == AppendMode::Sequence {
            self.group_start_timestamp.set(Some(self.group_end_timestamp.get()));
        }

        // Step 8.
        self.append_mode.set(new_mode);

        Ok(())
    }

    /// https://w3c.github.io/media-source/#dom-sourcebuffer-updating
    fn Updating(&self) -> bool {
        self.updating.get()
    }

    /// https://w3c.github.io/media-source/#dom-sourcebuffer-timestampoffset
    fn TimestampOffset(&self) -> Finite<f64> {
        self.timestamp_offset.get()
    }

    /// https://w3c.github.io/media-source/#dom-sourcebuffer-timestampoffset
    fn SetTimestampOffset(&self, new_timestamp_offset: Finite<f64>) -> ErrorResult {
        // Step 1.
        // The argument is already named new_timestamp_offset.

        // Step 2.
        let parent_media_source = match self.parent_media_source.get() {
            Some(source) => source,
            None => return Err(Error::InvalidState),
        };

        // Step 3.
        if self.updating.get() {
            return Err(Error::InvalidState);
        }

        // Step 4.
        if parent_media_source.ReadyState() == ReadyState::Ended {
            // Step 4.1.
            parent_media_source.set_ready_state(ReadyState::Open);

            // Step 4.2.
            let window = DomRoot::downcast::<Window>(parent_media_source.global()).unwrap();
            window.dom_manipulation_task_source().queue_simple_event(
                parent_media_source.upcast(),
                atom!("sourceopen"),
                &window,
            );
        }

        // Step 5.
        if self.append_state.get() == AppendState::ParsingMediaSegment {
            return Err(Error::InvalidState);
        }

        // Step 6.
        if self.append_mode.get() == AppendMode::Sequence {
            self.group_start_timestamp.set(Some(new_timestamp_offset));
        }

        // Step 7.
        self.timestamp_offset.set(new_timestamp_offset);

        Ok(())
    }

    /// https://w3c.github.io/media-source/#dom-sourcebuffer-appendwindowstart
    fn AppendWindowStart(&self) -> Finite<f64> {
        self.append_window_start.get()
    }

    /// https://w3c.github.io/media-source/#dom-sourcebuffer-appendwindowstart
    fn SetAppendWindowStart(&self, value: Finite<f64>) -> ErrorResult {
        // Step 1.
        if self.parent_media_source.get().is_none() {
            return Err(Error::InvalidState);
        }

        // Step 2.
        if self.updating.get() {
            return Err(Error::InvalidState);
        }

        // Step 3.
        if *value < 0. || *value >= self.append_window_end.get() {
            return Err(Error::Type("Value is out of range.".to_owned()));
        }

        // Step 4.
        self.append_window_start.set(value);

        Ok(())
    }

    /// https://w3c.github.io/media-source/#dom-sourcebuffer-appendwindowend
    fn AppendWindowEnd(&self) -> f64 {
        self.append_window_end.get()
    }

    /// https://w3c.github.io/media-source/#dom-sourcebuffer-appendwindowend
    fn SetAppendWindowEnd(&self, value: f64) -> ErrorResult {
        // Step 1.
        if self.parent_media_source.get().is_none() {
            return Err(Error::InvalidState);
        }

        // Step 2.
        if self.updating.get() {
            return Err(Error::InvalidState);
        }

        // Step 3.
        if value.is_nan() {
            return Err(Error::Type("Value is NaN.".to_owned()));
        }

        // Step 4.
        if value <= *self.append_window_start.get() {
            return Err(Error::Type("Value is out of range.".to_owned()));
        }

        // Step 5.
        self.append_window_end.set(value);

        Ok(())
    }

    event_handler!(updatestart, GetOnupdatestart, SetOnupdatestart);
    event_handler!(update, GetOnupdate, SetOnupdate);
    event_handler!(updateend, GetOnupdateend, SetOnupdateend);
    event_handler!(error, GetOnerror, SetOnerror);
    event_handler!(abort, GetOnabort, SetOnabort);

    /// https://w3c.github.io/media-source/#dom-sourcebuffer-appendbuffer
    #[allow(unsafe_code)]
    unsafe fn AppendBuffer(
        &self,
        cx: *mut JSContext,
        data: *mut JSObject,
    ) -> ErrorResult {
        let mut root_1 = Rooted::new_unrooted();
        let mut root_2 = Rooted::new_unrooted();
        let mut buffer_source = BufferSource::new(cx, &mut root_1, &mut root_2, data)?;
        self.append_buffer(&mut buffer_source)
    }

    /// https://w3c.github.io/media-source/#dom-sourcebuffer-abort
    fn Abort(&self) -> ErrorResult {
        // Step 1.
        let parent_media_source = match self.parent_media_source.get() {
            Some(source) => source,
            None => return Err(Error::InvalidState),
        };

        // Step 2.
        if parent_media_source.ReadyState() != ReadyState::Open {
            return Err(Error::InvalidState);
        }

        // Step 3.
        if self.in_range_removal.get() {
            return Err(Error::InvalidState);
        }

        // Step 4.
        if self.updating.get() {
            // Step 4.1.
            // FIXME(nox): Abort buffer append algorithm.

            // Step 4.2.
            self.updating.set(false);

            // Step 4.3.
            let window = DomRoot::downcast::<Window>(self.global()).unwrap();
            window.dom_manipulation_task_source().queue_simple_event(
                self.upcast(),
                atom!("abort"),
                &window,
            );

            // Step 4.4.
            window.dom_manipulation_task_source().queue_simple_event(
                self.upcast(),
                atom!("updateend"),
                &window,
            );
        }

        // Step 5.
        // FIXME(nox): Run the reset parser state algorithm.

        // Step 6.
        // This assumes that presentation start time is always 0.
        self.append_window_start.set(Default::default());

        // Step 7.
        self.append_window_end.set(f64::INFINITY);

        Ok(())
    }

    /// https://w3c.github.io/media-source/#dom-sourcebuffer-remove
    fn Remove(&self, start: Finite<f64>, end: f64) -> ErrorResult {
        // Step 1.
        let parent_media_source = match self.parent_media_source.get() {
            Some(source) => source,
            None => return Err(Error::InvalidState),
        };

        // Step 2.
        if self.updating.get() {
            return Err(Error::InvalidState);
        }

        // Step 3.
        let duration = parent_media_source.Duration();
        if duration.is_nan() {
            return Err(Error::Type("Parent media source's duration is NaN.".to_owned()));
        }

        // Step 4.
        if *start < 0. || *start > duration {
            return Err(Error::Type("Start value is out of range.".to_owned()));
        }

        // Step 5.
        if end <= *start {
            return Err(Error::Type("End value is out of range.".to_owned()));
        }
        if end.is_nan() {
            return Err(Error::Type("End value is NaN.".to_owned()));
        }

        // Step 6.
        if parent_media_source.ReadyState() == ReadyState::Ended {
            // Step 6.1.
            parent_media_source.set_ready_state(ReadyState::Open);

            // Step 6.2.
            let window = DomRoot::downcast::<Window>(parent_media_source.global()).unwrap();
            window.dom_manipulation_task_source().queue_simple_event(
                parent_media_source.upcast(),
                atom!("sourceopen"),
                &window,
            );
        }

        // Step 7.
        self.remove_range(start, end);

        Ok(())
    }
}

impl SourceBuffer {
    fn new_inherited(parent_media_source: &MediaSource, mime: Mime) -> Self {
        let timestamp_mode = Self::timestamp_mode(&mime);
        Self {
            eventtarget: EventTarget::new_inherited(),
            parent_media_source: MutNullableDom::new(Some(parent_media_source)),
            timestamp_mode,
            append_mode: Cell::new(timestamp_mode.into()),
            append_state: Cell::new(AppendState::WaitingForSegment),
            group_start_timestamp: Default::default(),
            group_end_timestamp: Default::default(),
            input_buffer: Default::default(),
            buffer_full: Default::default(),
            mime,
            in_range_removal: Default::default(),
            timestamp_offset: Default::default(),
            updating: Default::default(),
            // FIXME(nox): This assumes that the presentation start time is 0.
            append_window_start: Default::default(),
            append_window_end: Cell::new(f64::INFINITY),
        }
    }

    /// https://w3c.github.io/media-source/byte-stream-format-registry.html
    fn timestamp_mode(mime: &Mime) -> TimestampMode {
        match *mime {
            Mime(TopLevel::Audio, SubLevel::Mpeg, _) => TimestampMode::Generated,
            Mime(TopLevel::Audio, SubLevel::Ext(ref ext), _)
            if ext.eq_ignore_ascii_case("aac") => {
                TimestampMode::Generated
            },
            _ => TimestampMode::FromSource,
        }
    }

    /// https://w3c.github.io/media-source/#dom-sourcebuffer-appendbuffer
    #[allow(unsafe_code)]
    fn append_buffer(&self, buffer_source: &mut BufferSource) -> ErrorResult {
        // Step 1.
        self.prepare_append(buffer_source)?;

        // Step 2.
        self.input_buffer.borrow_mut().extend(unsafe { buffer_source.as_slice() });

        // Step 3.
        self.updating.set(true);

        // Step 4.
        let window = DomRoot::downcast::<Window>(self.global()).unwrap();
        window.dom_manipulation_task_source().queue_simple_event(
            self.upcast(),
            atom!("updatestart"),
            &window,
        );

        // Step 5.
        // FIXME(nox): Return to caller and run the rest in parallel, instead
        // of queueing a task.
        let this = Trusted::new(self);
        window.dom_manipulation_task_source().queue(
            task!(buffer_append: move || {
                this.root().buffer_append();
            }),
            window.upcast(),
        ).unwrap();

        Ok(())
    }

    /// https://w3c.github.io/media-source/#sourcebuffer-prepare-append
    fn prepare_append(&self, buffer_source: &mut BufferSource) -> ErrorResult {
        // Step 1.
        let parent_media_source = match self.parent_media_source.get() {
            Some(source) => source,
            None => return Err(Error::InvalidState),
        };

        // Step 2.
        if self.updating.get() {
            return Err(Error::InvalidState);
        }

        // Step 3.
        // FIXME(nox): Check HTMLMediaElement.error.

        // Step 4.
        if parent_media_source.ReadyState() == ReadyState::Ended {
            // Step 4.1.
            parent_media_source.set_ready_state(ReadyState::Open);

            // Step 4.2.
            let window = DomRoot::downcast::<Window>(parent_media_source.global()).unwrap();
            window.dom_manipulation_task_source().queue_simple_event(
                parent_media_source.upcast(),
                atom!("sourceopen"),
                &window,
            );
        }

        // Step 5.
        self.evict_coded_frames(buffer_source)?;

        // Step 6.
        if self.buffer_full.get() {
            return Err(Error::QuotaExceeded);
        }

        Ok(())
    }

    /// https://w3c.github.io/media-source/#sourcebuffer-buffer-append
    fn buffer_append(&self) {
        // Step 1.
        // FIXME(nox): Run the segment parser loop algorithm.

        // Step 2.
        // FIXME(nox): Propagate segment parser loop abortion if necessary.

        // Step 3.
        self.updating.set(false);

        // Step 4.
        let window = DomRoot::downcast::<Window>(self.global()).unwrap();
        window.dom_manipulation_task_source().queue_simple_event(
            self.upcast(),
            atom!("update"),
            &window,
        );

        // Step 5.
        window.dom_manipulation_task_source().queue_simple_event(
            self.upcast(),
            atom!("updateend"),
            &window,
        );
    }

    /// https://w3c.github.io/media-source/#sourcebuffer-coded-frame-eviction
    fn evict_coded_frames(&self, _buffer_source: &mut BufferSource) -> ErrorResult {
        // FIXME(nox): Actually implement this.
        Ok(())
    }

    /// https://w3c.github.io/media-source/#sourcebuffer-range-removal
    fn remove_range(&self, start: Finite<f64>, end: f64) {
        // Mark this SourceBuffer as being running the range removal algorithm,
        // so that the abort() method properly throws an exception.
        assert!(self.updating.get());
        self.in_range_removal.set(true);

        // Steps 1-2.
        // We assume that presentation start time is 0, thus we can just use
        // the arguments directly.

        // Step 3.
        self.updating.set(true);

        // Step 4.
        let window = DomRoot::downcast::<Window>(self.global()).unwrap();
        window.dom_manipulation_task_source().queue_simple_event(
            self.upcast(),
            atom!("updatestart"),
            &window,
        );

        // Step 5.
        // FIXME(nox): Return to caller and run the rest in parallel, instead
        // of queueing a task.
        let this = Trusted::new(self);
        window.dom_manipulation_task_source().queue(
            task!(range_removal: move || {
                let this = this.root();

                // Step 6.
                this.remove_coded_frames(start, end);

                // Step 7.
                this.updating.set(false);

                // Step 8.
                let window = DomRoot::downcast::<Window>(this.global()).unwrap();
                window.dom_manipulation_task_source().queue_simple_event(
                    this.upcast(),
                    atom!("update"),
                    &window,
                );

                // Step 9.
                window.dom_manipulation_task_source().queue_simple_event(
                    this.upcast(),
                    atom!("updateend"),
                    &window,
                );

                // FIXME(nox): I'm not too sure exactly if this should be done
                // at the very end of the range removal algorithm.
                this.in_range_removal.set(false);
            }),
            window.upcast(),
        ).unwrap();
    }

    /// https://w3c.github.io/media-source/#sourcebuffer-coded-frame-removal
    fn remove_coded_frames(&self, _start: Finite<f64>, _end: f64) {
        // Steps 1-2.
        // We assume that presentation start time is 0, thus we can just use
        // the arguments directly.

        // Step 3.
        // FIXME(nox): Loop through each track buffer and actually do work here.

        // Step 4.
        // FIXME(nox): Handle the buffer full flag.
    }
}

impl From<TimestampMode> for AppendMode {
    fn from(timestamp_mode: TimestampMode) -> Self {
        match timestamp_mode {
            TimestampMode::FromSource => AppendMode::Segments,
            TimestampMode::Generated => AppendMode::Sequence,
        }
    }
}

enum BufferSource<'root> {
    ArrayBuffer(ArrayBuffer<'root>),
    ArrayBufferView(ArrayBufferView<'root>),
}

impl<'root> BufferSource<'root> {
    #[allow(unsafe_code)]
    unsafe fn new(
        cx: *mut JSContext,
        root_1: &'root mut Rooted<*mut JSObject>,
        root_2: &'root mut Rooted<*mut JSObject>,
        data: *mut JSObject,
    ) -> Fallible<Self> {
        if let Ok(array) = ArrayBuffer::from(cx, root_1, data) {
            return Ok(BufferSource::ArrayBuffer(array));
        } else if let Ok(view) = ArrayBufferView::from(cx, root_2, data) {
            return Ok(BufferSource::ArrayBufferView(view));
        }
        Err(Error::Type("Object should be an ArrayBuffer or ArrayBufferView.".to_owned()))
    }

    #[allow(unsafe_code)]
    unsafe fn as_slice(&mut self) -> &[u8] {
        match *self {
            BufferSource::ArrayBuffer(ref mut array) => array.as_slice(),
            BufferSource::ArrayBufferView(ref mut view) => view.as_slice(),
        }
    }
}
